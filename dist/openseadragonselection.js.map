{"version":3,"sources":["selection.js","selectionoverlay.js","selectionrect.js"],"names":["$","checkMinimumRect","self","cropMinimumSize","minPoint","viewer","viewport","imageToViewportCoordinates","cropMinimumWidth","cropMinimumHeight","rect","width","x","height","y","onOutsideDrag","e","this","setMouseNavEnabled","delta","deltaPointsFromPixels","end","pointFromPixel","position","start","Point","oldRect","restrictToImage","clone","rectDone","allowRotation","angle1","getAngleFromCenter","angle2","rotation","Math","PI","startRotated","getPrerotatedRect","rotatedStartPoint","startRotatedHeight","bounds","world","getHomeBounds","fitsIn","Rect","pointIsInImage","restrictVector","SelectionRect","draw","onOutsideDragEnd","abs","onClick","canvas","focus","onInsideDrag","addClass","element","onInsideDragEnd","removeClass","onBorderDrag","border","center","getDegreeRotation","rotate","getCenter","newCenter","target","minus","onBorderDragEnd","onKeyPress","key","keyCode","charCode","confirm","String","fromCharCode","keyboardShortcut","toggleState","dist","distanceTo","angle","atan2","heightModDelta","point","prop","version","major","Error","Viewer","prototype","selection","options","selectionInstance","Selection","extend","isSelecting","buttonActiveImg","toggleButton","showSelectionControl","showConfirmDenyButtons","styleConfirmDenyButtons","returnPixelCoordinates","onSelection","prefixUrl","navImages","REST","GROUP","HOVER","DOWN","selectionConfirm","selectionCancel","borderStyle","color","handleStyle","top","left","margin","background","cornersStyle","makeNeutralElement","style","className","borders","handle","corners","i","MouseTracker","dragHandler","bind","dragEndHandler","appendChild","setTimeout","right","bottom","overlay","SelectionOverlay","innerTracker","clickTimeThreshold","clickDistThreshold","delegate","clickHandler","outerTracker","startDisabled","addEvent","container","prefix","useGroup","buttons","anyButton","onFocusHandler","onFocus","onBlurHandler","onBlur","Button","getElement","tooltip","getString","srcRest","srcGroup","srcHover","srcDown","onRelease","push","imgDown","cloneNode","confirmButton","classList","add","cancelButton","cancel","transform","addHandler","ControlDock","setState","enabled","setTracking","undraw","visibility","raiseEvent","setAllowRotation","enable","disable","update","normalize","drawHTML","drawer","destroy","result","real","viewportToImageRectangle","fromRect","round","OpenSeadragon","location","Overlay","apply","arguments","isPlainObject","Object","create","replace","equals","other","toString","swapWidthHeight","swapped","diff","fixed","area","getTopLeft","getTopRight","getBottomRight","getBottomLeft","areaEnd","reduceRotation","reduced"],"mappings":"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","file":"openseadragonselection.js","sourcesContent":["(function($) {\n  'use strict';\n\n  if (!$.version || $.version.major < 2) {\n      throw new Error('This version of OpenSeadragonSelection requires OpenSeadragon version 2.0.0+');\n  }\n\n  $.Viewer.prototype.selection = function(options) {\n      if (!this.selectionInstance || options) {\n          options = options || {};\n          options.viewer = this;\n          this.selectionInstance = new $.Selection(options);\n      }\n      return this.selectionInstance;\n  };\n\n\n  /**\n  * @class Selection\n  * @classdesc Provides functionality for selecting part of an image\n  * @memberof OpenSeadragon\n  * @param {Object} options\n  */\n  $.Selection = function ( options ) {\n\n      $.extend( true, this, {\n          // internal state properties\n          viewer:                  null,\n          isSelecting:             false,\n          buttonActiveImg:         false,\n          rectDone:                true,\n\n          // options\n          element:                 null,\n          toggleButton:            null,\n          showSelectionControl:    true,\n          showConfirmDenyButtons:  true,\n          styleConfirmDenyButtons: true,\n          returnPixelCoordinates:  true,\n          keyboardShortcut:        'c',\n          rect:                    null,\n          allowRotation:           true,\n          startRotated:            false, // useful for rotated crops\n          startRotatedHeight:      0.1,\n          restrictToImage:         false,\n          cropMinimumSize:         false,\n          cropMinimumWidth:        0,\n          cropMinimumHeight:       0,\n          onSelection:             null,\n          prefixUrl:               null,\n          navImages:               {\n              selection: {\n                  REST:   'selection_rest.png',\n                  GROUP:  'selection_grouphover.png',\n                  HOVER:  'selection_hover.png',\n                  DOWN:   'selection_pressed.png'\n              },\n              selectionConfirm: {\n                  REST:   'selection_confirm_rest.png',\n                  GROUP:  'selection_confirm_grouphover.png',\n                  HOVER:  'selection_confirm_hover.png',\n                  DOWN:   'selection_confirm_pressed.png'\n              },\n              selectionCancel: {\n                  REST:   'selection_cancel_rest.png',\n                  GROUP:  'selection_cancel_grouphover.png',\n                  HOVER:  'selection_cancel_hover.png',\n                  DOWN:   'selection_cancel_pressed.png'\n              },\n          },\n          borderStyle: {\n              width:      '1px',\n              color:      '#fff'\n          },\n          handleStyle: {\n              top:        '50%',\n              left:       '50%',\n              width:      '6px',\n              height:     '6px',\n              margin:     '-4px 0 0 -4px',\n              background: '#000',\n              border:     '1px solid #ccc'\n          },\n          cornersStyle: {\n              width:      '6px',\n              height:     '6px',\n              background: '#000',\n              border:     '1px solid #ccc'\n          }\n\n      }, options );\n\n      $.extend( true, this.navImages, this.viewer.navImages );\n\n      if (!this.element) {\n          this.element = $.makeNeutralElement('div');\n          this.element.style.background = 'rgba(0, 0, 0, 0.1)';\n          this.element.className        = 'selection-box';\n      }\n      this.borders = this.borders || [];\n      var handle;\n      var corners = [];\n      for (var i = 0; i < 4; i++) {\n          if (!this.borders[i]) {\n              this.borders[i]                  = $.makeNeutralElement('div');\n              this.borders[i].className        = 'border-' + i;\n              this.borders[i].style.position   = 'absolute';\n              this.borders[i].style.width      = this.borderStyle.width;\n              this.borders[i].style.height     = this.borderStyle.width;\n              this.borders[i].style.background = this.borderStyle.color;\n          }\n\n          handle                  = $.makeNeutralElement('div');\n          handle.className        = 'border-' + i + '-handle';\n          handle.style.position   = 'absolute';\n          handle.style.top        = this.handleStyle.top;\n          handle.style.left       = this.handleStyle.left;\n          handle.style.width      = this.handleStyle.width;\n          handle.style.height     = this.handleStyle.height;\n          handle.style.margin     = this.handleStyle.margin;\n          handle.style.background = this.handleStyle.background;\n          handle.style.border     = this.handleStyle.border;\n          new $.MouseTracker({\n              element:     this.borders[i],\n              dragHandler: onBorderDrag.bind(this, i),\n              dragEndHandler: onBorderDragEnd.bind(this, i),\n          });\n\n          corners[i]                  = $.makeNeutralElement('div');\n          corners[i].className        = 'corner-' + i + '-handle';\n          corners[i].style.position   = 'absolute';\n          corners[i].style.width      = this.cornersStyle.width;\n          corners[i].style.height     = this.cornersStyle.height;\n          corners[i].style.background = this.cornersStyle.background;\n          corners[i].style.border     = this.cornersStyle.border;\n          new $.MouseTracker({\n              element:     corners[i],\n              dragHandler: onBorderDrag.bind(this, i + 0.5),\n              dragEndHandler: onBorderDragEnd.bind(this, i),\n          });\n\n          this.borders[i].appendChild(handle);\n          this.element.appendChild(this.borders[i]);\n          // defer corners, so they are appended last\n          setTimeout(this.element.appendChild.bind(this.element, corners[i]), 0);\n      }\n      this.borders[0].style.top = 0;\n      this.borders[0].style.width = '100%';\n      this.borders[1].style.right = 0;\n      this.borders[1].style.height = '100%';\n      this.borders[2].style.bottom = 0;\n      this.borders[2].style.width = '100%';\n      this.borders[3].style.left = 0;\n      this.borders[3].style.height = '100%';\n      corners[0].style.top = '-3px';\n      corners[0].style.left = '-3px';\n      corners[1].style.top = '-3px';\n      corners[1].style.right = '-3px';\n      corners[2].style.bottom = '-3px';\n      corners[2].style.right = '-3px';\n      corners[3].style.bottom = '-3px';\n      corners[3].style.left = '-3px';\n\n      if (!this.overlay) {\n          this.overlay = new $.SelectionOverlay(this.element, this.rect || new $.SelectionRect());\n      }\n\n      this.innerTracker = new $.MouseTracker({\n          element:            this.element,\n          clickTimeThreshold: this.viewer.clickTimeThreshold,\n          clickDistThreshold: this.viewer.clickDistThreshold,\n          dragHandler:        $.delegate( this, onInsideDrag ),\n          dragEndHandler:     $.delegate( this, onInsideDragEnd ),\n          // keyHandler:         $.delegate( this, onKeyPress ),\n          clickHandler:       $.delegate( this, onClick ),\n          // scrollHandler:      $.delegate( this.viewer, this.viewer.innerTracker.scrollHandler ),\n          // pinchHandler:       $.delegate( this.viewer, this.viewer.innerTracker.pinchHandler ),\n      });\n\n      this.outerTracker = new $.MouseTracker({\n          element:            this.viewer.canvas,\n          clickTimeThreshold: this.viewer.clickTimeThreshold,\n          clickDistThreshold: this.viewer.clickDistThreshold,\n          dragHandler:        $.delegate( this, onOutsideDrag ),\n          dragEndHandler:     $.delegate( this, onOutsideDragEnd ),\n          clickHandler:       $.delegate( this, onClick ),\n          startDisabled:      !this.isSelecting,\n      });\n\n      if (this.keyboardShortcut) {\n          $.addEvent(\n              this.viewer.container,\n              'keypress',\n              $.delegate(this, onKeyPress),\n              false\n          );\n      }\n\n      var prefix = this.prefixUrl || this.viewer.prefixUrl || '';\n      var useGroup = this.viewer.buttons && this.viewer.buttons.buttons;\n      var anyButton = useGroup ? this.viewer.buttons.buttons[0] : null;\n      var onFocusHandler = anyButton ? anyButton.onFocus : null;\n      var onBlurHandler = anyButton ? anyButton.onBlur : null;\n      if (this.showSelectionControl) {\n          this.toggleButton = new $.Button({\n              element:    this.toggleButton ? $.getElement( this.toggleButton ) : null,\n              clickTimeThreshold: this.viewer.clickTimeThreshold,\n              clickDistThreshold: this.viewer.clickDistThreshold,\n              tooltip:    $.getString('Tooltips.SelectionToggle') || 'Toggle selection',\n              srcRest:    prefix + this.navImages.selection.REST,\n              srcGroup:   prefix + this.navImages.selection.GROUP,\n              srcHover:   prefix + this.navImages.selection.HOVER,\n              srcDown:    prefix + this.navImages.selection.DOWN,\n              onRelease:  this.toggleState.bind( this ),\n              onFocus:    onFocusHandler,\n              onBlur:     onBlurHandler\n          });\n          if (useGroup) {\n              this.viewer.buttons.buttons.push(this.toggleButton);\n              this.viewer.buttons.element.appendChild(this.toggleButton.element);\n          }\n          if (this.toggleButton.imgDown) {\n              this.buttonActiveImg = this.toggleButton.imgDown.cloneNode(true);\n              this.toggleButton.element.appendChild(this.buttonActiveImg);\n          }\n      }\n      if (this.showConfirmDenyButtons) {\n          this.confirmButton = new $.Button({\n              element:    this.confirmButton ? $.getElement( this.confirmButton ) : null,\n              clickTimeThreshold: this.viewer.clickTimeThreshold,\n              clickDistThreshold: this.viewer.clickDistThreshold,\n              tooltip:    $.getString('Tooltips.SelectionConfirm') || 'Confirm selection',\n              srcRest:    prefix + this.navImages.selectionConfirm.REST,\n              srcGroup:   prefix + this.navImages.selectionConfirm.GROUP,\n              srcHover:   prefix + this.navImages.selectionConfirm.HOVER,\n              srcDown:    prefix + this.navImages.selectionConfirm.DOWN,\n              onRelease:  this.confirm.bind( this ),\n              onFocus:    onFocusHandler,\n              onBlur:     onBlurHandler\n          });\n          var confirm = this.confirmButton.element;\n          confirm.classList.add('confirm-button');\n          this.element.appendChild(confirm);\n\n          this.cancelButton = new $.Button({\n              element:    this.cancelButton ? $.getElement( this.cancelButton ) : null,\n              clickTimeThreshold: this.viewer.clickTimeThreshold,\n              clickDistThreshold: this.viewer.clickDistThreshold,\n              tooltip:    $.getString('Tooltips.SelectionCancel') || 'Cancel selection',\n              srcRest:    prefix + this.navImages.selectionCancel.REST,\n              srcGroup:   prefix + this.navImages.selectionCancel.GROUP,\n              srcHover:   prefix + this.navImages.selectionCancel.HOVER,\n              srcDown:    prefix + this.navImages.selectionCancel.DOWN,\n              onRelease:  this.cancel.bind( this ),\n              onFocus:    onFocusHandler,\n              onBlur:     onBlurHandler\n          });\n          var cancel = this.cancelButton.element;\n          cancel.classList.add('cancel-button');\n          this.element.appendChild(cancel);\n\n          if (this.styleConfirmDenyButtons) {\n              confirm.style.position = 'absolute';\n              confirm.style.top = '50%';\n              confirm.style.left = '50%';\n              confirm.style.transform = 'translate(-100%, -50%)';\n\n              cancel.style.position = 'absolute';\n              cancel.style.top = '50%';\n              cancel.style.left = '50%';\n              cancel.style.transform = 'translate(0, -50%)';\n          }\n      }\n\n      this.viewer.addHandler('selection', this.onSelection);\n\n      this.viewer.addHandler('open', this.draw.bind(this));\n      this.viewer.addHandler('animation', this.draw.bind(this));\n      this.viewer.addHandler('resize', this.draw.bind(this));\n      this.viewer.addHandler('rotate', this.draw.bind(this));\n  };\n\n  $.extend( $.Selection.prototype, $.ControlDock.prototype, /** @lends OpenSeadragon.Selection.prototype */{\n\n      toggleState: function() {\n          return this.setState(!this.isSelecting);\n      },\n\n      setState: function(enabled) {\n          this.isSelecting = enabled;\n          // this.viewer.innerTracker.setTracking(!enabled);\n          this.outerTracker.setTracking(enabled);\n          enabled ? this.draw() : this.undraw();\n          if (this.buttonActiveImg) {\n              this.buttonActiveImg.style.visibility = enabled ? 'visible' : 'hidden';\n          }\n          this.viewer.raiseEvent('selection_toggle', {enabled: enabled});\n          return this;\n      },\n\n      setAllowRotation: function(allowRotation) {\n          this.allowRotation = allowRotation;\n      },\n\n      enable: function() {\n          return this.setState(true);\n      },\n\n      disable: function() {\n          return this.setState(false);\n      },\n\n      draw: function() {\n          if (this.rect) {\n              this.overlay.update(this.rect.normalize());\n              this.overlay.drawHTML(this.viewer.drawer.container, this.viewer.viewport);\n          }\n          return this;\n      },\n\n      undraw: function() {\n          this.overlay.destroy();\n          this.rect = null;\n          return this;\n      },\n\n      confirm: function() {\n          if (this.rect) {\n              var result = this.rect.normalize();\n              if (this.returnPixelCoordinates) {\n                  var real = this.viewer.viewport.viewportToImageRectangle(result);\n                  real = $.SelectionRect.fromRect(real).round();\n                  real.rotation = result.rotation;\n                  result = real;\n              }\n              this.viewer.raiseEvent('selection', result);\n              this.undraw();\n          }\n          return this;\n      },\n\n      cancel: function() {\n          /*\n           * These two lines have been added to fix a issue with mobile where the selection is just a pinpoint after the first drag\n           * For some reason disabling then re-enabling the tracking fixes this issue.\n           */\n          this.outerTracker.setTracking(false);\n          this.outerTracker.setTracking(true);\n          this.viewer.raiseEvent('selection_cancel', false);\n          return this.undraw();\n      },\n  });\n\n  function checkMinimumRect(self) {\n    if (self.cropMinimumSize === true) {\n        const minPoint = self.viewer.viewport.imageToViewportCoordinates(self.cropMinimumWidth, self.cropMinimumHeight);\n        self.rect.width = (self.rect.width < minPoint.x) ? minPoint.x : self.rect.width;\n        self.rect.height = (self.rect.height < minPoint.y) ? minPoint.y : self.rect.height;\n    }\n  }\n\n  function onOutsideDrag(e) {\n      // Disable move when makeing new selection\n      this.viewer.setMouseNavEnabled(false);\n      var delta = this.viewer.viewport.deltaPointsFromPixels(e.delta, true);\n      var end = this.viewer.viewport.pointFromPixel(e.position, true);\n      var start = new $.Point(end.x - delta.x, end.y - delta.y);\n      if (!this.rect) {\n          if (this.restrictToImage) {\n              if (!pointIsInImage(this, start)) {\n                  return;\n              }\n              restrictVector(delta, end);\n          }\n          if (this.startRotated) {\n              this.rotatedStartPoint = start;\n              this.rect = getPrerotatedRect(start, end, this.startRotatedHeight);\n          } else {\n              this.rect = new $.SelectionRect(start.x, start.y, delta.x, delta.y);\n          }\n          this.rectDone = false;\n      } else {\n          var oldRect;\n          if (this.restrictToImage || this.cropMinimumSize) {\n              oldRect = this.rect.clone();\n          }\n          if (this.rectDone) {\n              // All rotation as needed.\n              if (this.allowRotation) {\n                  var angle1 = this.rect.getAngleFromCenter(start);\n                  var angle2 = this.rect.getAngleFromCenter(end);\n                  this.rect.rotation = (this.rect.rotation + angle1 - angle2) % Math.PI;\n              }\n          } else {\n              if (this.startRotated) {\n                  this.rect = getPrerotatedRect(this.rotatedStartPoint, end, this.startRotatedHeight);\n              } else {\n                  this.rect.width += delta.x;\n                  this.rect.height += delta.y;\n              }\n          }\n          var bounds = this.viewer.world.getHomeBounds();\n          if (this.restrictToImage && !this.rect.fitsIn(new $.Rect(0, 0, bounds.width, bounds.height))) {\n              this.rect = oldRect;\n          }\n      }\n      checkMinimumRect(this);\n      this.draw();\n  }\n\n  function onOutsideDragEnd() {\n      // Resizing a selection will function\n      // when drawn any direction\n      if (this.rect.width < 0){\n          this.rect.x += this.rect.width;\n          this.rect.width = Math.abs(this.rect.width);\n      }\n      if (this.rect.height < 0){\n          this.rect.y += this.rect.height;\n          this.rect.height = Math.abs(this.rect.height);\n      }\n\n      // Eable move after new selection is done\n      this.viewer.setMouseNavEnabled(true);\n      this.rectDone = true;\n  }\n\n  function onClick() {\n      this.viewer.canvas.focus();\n  }\n\n  function onInsideDrag(e) {\n      $.addClass(this.element, 'dragging');\n      var delta = this.viewer.viewport.deltaPointsFromPixels(e.delta, true);\n      this.rect.x += delta.x;\n      this.rect.y += delta.y;\n      var bounds = this.viewer.world.getHomeBounds();\n      if (this.restrictToImage && !this.rect.fitsIn(new $.Rect(0, 0, bounds.width, bounds.height))) {\n          this.rect.x -= delta.x;\n          this.rect.y -= delta.y;\n      }\n      checkMinimumRect(this);\n      this.draw();\n  }\n\n  function onInsideDragEnd() {\n      $.removeClass(this.element, 'dragging');\n  }\n\n  function onBorderDrag(border, e) {\n      var delta = e.delta;\n      var rotation = this.rect.getDegreeRotation();\n      var center;\n      var oldRect = (this.restrictToImage || this.cropMinimumSize) ? this.rect.clone() : null;\n      if (rotation !== 0) {\n          // adjust vector\n          delta = delta.rotate(-1 * rotation, new $.Point(0, 0));\n          center = this.rect.getCenter();\n      }\n      delta = this.viewer.viewport.deltaPointsFromPixels(delta, true);\n      switch (border) {\n          case 0:\n              this.rect.y += delta.y;\n              this.rect.height -= delta.y;\n              break;\n          case 1:\n              this.rect.width += delta.x;\n              break;\n          case 2:\n              this.rect.height += delta.y;\n              break;\n          case 3:\n              this.rect.x += delta.x;\n              this.rect.width -= delta.x;\n              break;\n          case 0.5:\n              this.rect.y += delta.y;\n              this.rect.height -= delta.y;\n              this.rect.x += delta.x;\n              this.rect.width -= delta.x;\n              break;\n          case 1.5:\n              this.rect.y += delta.y;\n              this.rect.height -= delta.y;\n              this.rect.width += delta.x;\n              break;\n          case 2.5:\n              this.rect.width += delta.x;\n              this.rect.height += delta.y;\n              break;\n          case 3.5:\n              this.rect.height += delta.y;\n              this.rect.x += delta.x;\n              this.rect.width -= delta.x;\n              break;\n      }\n      if (rotation !== 0) {\n          // calc center deviation\n          var newCenter = this.rect.getCenter();\n          // rotate new center around old\n          var target = newCenter.rotate(rotation, center);\n          // adjust new center\n          delta = target.minus(newCenter);\n          this.rect.x += delta.x;\n          this.rect.y += delta.y;\n      }\n      var bounds = this.viewer.world.getHomeBounds();\n      if (this.restrictToImage && !this.rect.fitsIn(new $.Rect(0, 0, bounds.width, bounds.height))) {\n          this.rect = oldRect;\n      }\n      checkMinimumRect(this);\n      this.draw();\n  }\n\n  // After you have completed dragging, ensure the top left of the selection\n  // box is still the top left corner of the box\n  function onBorderDragEnd(){\n      if (this.rect.width < 0){\n          this.rect.x += this.rect.width;\n          this.rect.width = Math.abs(this.rect.width);\n      }\n      if (this.rect.height < 0){\n          this.rect.y += this.rect.height;\n          this.rect.height = Math.abs(this.rect.height);\n      }\n  }\n\n  function onKeyPress(e) {\n      var key = e.keyCode ? e.keyCode : e.charCode;\n      if (key === 13) {\n          this.confirm();\n      } else if (String.fromCharCode(key) === this.keyboardShortcut) {\n          this.toggleState();\n      }\n  }\n\n  function getPrerotatedRect(start, end, height) {\n      if (start.x > end.x) {\n          // always draw left to right\n          var x = start;\n          start = end;\n          end = x;\n      }\n      var delta = end.minus(start);\n      var dist = start.distanceTo(end);\n      var angle = -1 * Math.atan2(delta.x, delta.y) + (Math.PI / 2);\n      var center = new $.Point(\n          delta.x / 2 + start.x,\n          delta.y / 2 + start.y\n      );\n      var rect = new $.SelectionRect(\n          center.x - (dist / 2),\n          center.y - (height / 2),\n          dist,\n          height,\n          angle\n      );\n      var heightModDelta = new $.Point(0, height);\n      heightModDelta = heightModDelta.rotate(rect.getDegreeRotation(), new $.Point(0, 0));\n      rect.x += heightModDelta.x / 2;\n      rect.y += heightModDelta.y / 2;\n      return rect;\n  }\n\n  function pointIsInImage(self, point) {\n      var bounds = self.viewer.world.getHomeBounds();\n      return point.x >= 0 && point.x <= bounds.width && point.y >= 0 && point.y <= bounds.height;\n  }\n\n  function restrictVector(delta, end) {\n      var start;\n      for (var prop in {x: 0, y: 0}) {\n          start = end[prop] - delta[prop];\n          if (start < 1 && start > 0) {\n              if (end[prop] > 1) {\n                  delta[prop] -= end[prop] - 1;\n                  end[prop] = 1;\n              } else if (end[prop] < 0) {\n                  delta[prop] -= end[prop];\n                  end[prop] = 0;\n              }\n          }\n      }\n  }\n\n})(OpenSeadragon);\n","(function( $ ){\n    'use strict';\n\n    /**\n     * @class Overlay\n     * @classdesc Provides a way to float an HTML element on top of the viewer element.\n     *\n     * @memberof OpenSeadragon\n     * @param {Object} options\n     * @param {Element} options.element\n     * @param {OpenSeadragon.Point|OpenSeadragon.Rect|OpenSeadragon.SelectionRect} options.location - The\n     * location of the overlay on the image. If a {@link OpenSeadragon.Point}\n     * is specified, the overlay will keep a constant size independently of the\n     * zoom. If a {@link OpenSeadragon.Rect} is specified, the overlay size will\n     * be adjusted when the zoom changes.\n     * @param {OpenSeadragon.OverlayPlacement} [options.placement=OpenSeadragon.OverlayPlacement.TOP_LEFT]\n     * Relative position to the viewport.\n     * Only used if location is a {@link OpenSeadragon.Point}.\n     * @param {OpenSeadragon.Overlay.OnDrawCallback} [options.onDraw]\n     * @param {Boolean} [options.checkResize=true] Set to false to avoid to\n     * check the size of the overlay everytime it is drawn when using a\n     * {@link OpenSeadragon.Point} as options.location. It will improve\n     * performances but will cause a misalignment if the overlay size changes.\n     */\n    $.SelectionOverlay = function( element, location) {\n        $.Overlay.apply( this, arguments );\n\n        // set the rotation in radians\n        if ( $.isPlainObject( element ) ) {\n            this.rotation = element.location.rotation || 0;\n        } else {\n            this.rotation = location.rotation || 0;\n        }\n    };\n\n    $.SelectionOverlay.prototype = $.extend( Object.create($.Overlay.prototype), {\n\n        /**\n         * @function\n         * @param {Element} container\n         */\n        drawHTML: function() {\n            $.Overlay.prototype.drawHTML.apply( this, arguments );\n            this.style.transform = this.style.transform.replace(/ ?rotate\\(.+rad\\)/, '') +\n                ' rotate(' + this.rotation + 'rad)';\n        },\n\n        /**\n         * @function\n         * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location\n         * @param {OpenSeadragon.OverlayPlacement} position\n         */\n        update: function( location ) {\n            $.Overlay.prototype.update.apply( this, arguments );\n            this.rotation = location.rotation || 0;\n        }\n    });\n\n}( OpenSeadragon ));\n","(function( $ ){\n    'use strict';\n\n    /**\n     * @class SelectionRect\n     * @classdesc A display rectangle is very similar to {@link OpenSeadragon.Rect} but adds rotation\n     * around the center point\n     *\n     * @memberof OpenSeadragon\n     * @extends OpenSeadragon.Rect\n     * @param {Number} x The vector component 'x'.\n     * @param {Number} y The vector component 'y'.\n     * @param {Number} width The vector component 'height'.\n     * @param {Number} height The vector component 'width'.\n     * @param {Number} rotation The rotation in radians\n     */\n    $.SelectionRect = function( x, y, width, height, rotation ) {\n        $.Rect.apply( this, [ x, y, width, height ] );\n\n        /**\n         * The rotation in radians\n         * @member {Number} rotation\n         * @memberof OpenSeadragon.SelectionRect#\n         */\n        this.rotation = rotation || 0;\n    };\n\n    $.SelectionRect.fromRect = function(rect) {\n        return new $.SelectionRect(\n            rect.x,\n            rect.y,\n            rect.width,\n            rect.height\n        );\n    };\n\n    $.SelectionRect.prototype = $.extend( Object.create($.Rect.prototype), {\n\n        /**\n         * @function\n         * @returns {OpenSeadragon.Rect} a duplicate of this Rect\n         */\n        clone: function() {\n            return new $.SelectionRect(this.x, this.y, this.width, this.height, this.rotation);\n        },\n\n        /**\n         * Determines if two Rectangles have equivalent components.\n         * @function\n         * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.\n         * @return {Boolean} 'true' if all components are equal, otherwise 'false'.\n         */\n        equals: function( other ) {\n            return $.Rect.prototype.equals.apply(this, [ other ]) &&\n                ( this.rotation === other.rotation );\n        },\n\n        /**\n         * Provides a string representation of the rectangle which is useful for\n         * debugging.\n         * @function\n         * @returns {String} A string representation of the rectangle.\n         */\n        toString: function() {\n            return '[' +\n                (Math.round(this.x*100) / 100) + ',' +\n                (Math.round(this.y*100) / 100) + ',' +\n                (Math.round(this.width*100) / 100) + 'x' +\n                (Math.round(this.height*100) / 100) + '@' +\n                (Math.round(this.rotation*100) / 100) +\n            ']';\n        },\n\n        swapWidthHeight: function() {\n            var swapped = this.clone();\n            swapped.width = this.height;\n            swapped.height = this.width;\n            swapped.x += (this.width - this.height) / 2;\n            swapped.y += (this.height - this.width) / 2;\n            return swapped;\n        },\n\n        /**\n         * @function\n         * @returns {Number} The rotaion in degrees\n         */\n        getDegreeRotation: function() {\n            return this.rotation * (180/Math.PI);\n        },\n\n        /**\n         * @function\n         * @param {OpenSeadragon.Point} point\n         * @returns {Number} The angle in radians\n         */\n        getAngleFromCenter: function(point) {\n            var diff = point.minus(this.getCenter());\n            return Math.atan2(diff.x, diff.y);\n        },\n\n        /**\n         * Rounds pixel coordinates\n         * @function\n         * @returns {SelectionRect} The altered rect\n         */\n        round: function() {\n            return new $.SelectionRect(\n                Math.round(this.x),\n                Math.round(this.y),\n                Math.round(this.width),\n                Math.round(this.height),\n                this.rotation\n            );\n        },\n\n        /**\n         * Fixes negative width/height, rotation larger than PI\n         * @function\n         * @returns {SelectionRect} The normalized rect\n         */\n        normalize: function() {\n            var fixed = this.clone();\n            if (fixed.width < 0) {\n                fixed.x += fixed.width;\n                fixed.width *= -1;\n            }\n            if (fixed.height < 0) {\n                fixed.y += fixed.height;\n                fixed.height *= -1;\n            }\n            fixed.rotation %= Math.PI;\n            return fixed;\n        },\n\n        /**\n         * @function\n         * @param {OpenSeadragon.Rect} area\n         * @returns {Boolean} Does this rect fit in a specified area\n         */\n        fitsIn: function(area) {\n            var rect = this.normalize();\n            var corners = [\n                rect.getTopLeft(),\n                rect.getTopRight(),\n                rect.getBottomRight(),\n                rect.getBottomLeft(),\n            ];\n            var center = rect.getCenter();\n            var rotation = rect.getDegreeRotation();\n            var areaEnd = area.getBottomRight();\n            for (var i = 0; i < 4; i++) {\n                corners[i] = corners[i].rotate(rotation, center);\n                if (corners[i].x < area.x || corners[i].x > areaEnd.x ||\n                    corners[i].y < area.y || corners[i].y > areaEnd.y) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n         * Reduces rotation to within [-45, 45] degrees by swapping width & height\n         * @function\n         * @returns {SelectionRect} The altered rect\n         */\n        reduceRotation: function() {\n            var reduced;\n            if (this.rotation < Math.PI / (-4)) {\n                reduced = this.swapWidthHeight();\n                reduced.rotation += Math.PI / 2;\n            } else if (this.rotation > Math.PI / 4) {\n                reduced = this.swapWidthHeight();\n                reduced.rotation -= Math.PI / 2;\n            } else {\n                reduced = this.clone();\n            }\n            return reduced;\n        },\n    });\n\n}( OpenSeadragon ));\n"]}